/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * nlmpc_config__stateFcnJacobian.c
 *
 * Code generation for function 'nlmpc_config__stateFcnJacobian'
 *
 */

/* Include files */
#include "nlmpc_config__stateFcnJacobian.h"
#include "mtimes.h"
#include "nlmpcmoveCodeGeneration_data.h"
#include "rt_nonfinite.h"
#include "mwmathutil.h"
#include <string.h>

/* Type Definitions */
#ifndef typedef_cell_5
#define typedef_cell_5
typedef struct {
  real_T f1[12];
  real_T f2;
  real_T f3;
  real_T f4;
  real_T f5[196];
  real_T f6[56];
  real_T f7[112];
} cell_5;
#endif /* typedef_cell_5 */

#ifndef typedef_struct_T
#define typedef_struct_T
typedef struct {
  cell_5 constants;
} struct_T;
#endif /* typedef_struct_T */

/* Variable Definitions */
static boolean_T ADdata_not_empty;

/* Function Definitions */
void c_nlmpc_config__stateFcnJacobia(void)
{
  ADdata_not_empty = false;
}

void nlmpc_config__stateFcnJacobian(real_T Jx[196], real_T Ju[56])
{
  static struct_T ADdata;
  static const real_T currAdjoint[196] = {
      1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0};
  static const int8_T b_iv[12] = {0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0};
  real_T J[252];
  real_T arg41[252];
  real_T b_currAdjoint[196];
  real_T b_rightJac[196];
  real_T unusedExpr[112];
  real_T rightJac[56];
  int32_T b_i;
  int32_T i;
  int8_T idxRowsAdj[14];
  boolean_T IsFiniteLeft;
  boolean_T exitg1;
  /*  This function was generated by Model Predictive Control Toolbox
   * (Version 24.1). */
  /*  2024/05/07 03:19:27 */
  if (!ADdata_not_empty) {
    for (i = 0; i < 12; i++) {
      ADdata.constants.f1[i] = b_iv[i];
    }
    ADdata.constants.f2 = 0.275;
    ADdata.constants.f3 = 0.275;
    ADdata.constants.f4 = 9.80665;
    memcpy(&ADdata.constants.f5[0], &dv[0], 196U * sizeof(real_T));
    memcpy(&ADdata.constants.f6[0], &dv1[0], 56U * sizeof(real_T));
    memcpy(&ADdata.constants.f7[0], &dv2[0], 112U * sizeof(real_T));
    ADdata_not_empty = true;
  }
  memset(&arg41[0], 0, 252U * sizeof(real_T));
  IsFiniteLeft = true;
  i = 0;
  exitg1 = false;
  while ((!exitg1) && (i < 112)) {
    if (muDoubleScalarIsInf(ADdata.constants.f7[i]) ||
        muDoubleScalarIsNaN(ADdata.constants.f7[i])) {
      IsFiniteLeft = false;
      exitg1 = true;
    } else {
      i++;
    }
  }
  if (IsFiniteLeft) {
    mtimes(ADdata.constants.f7, currAdjoint, unusedExpr);
  } else {
    for (i = 0; i < 14; i++) {
      idxRowsAdj[i] = (int8_T)(i + 1);
    }
    for (b_i = 0; b_i < 14; b_i++) {
      for (i = 0; i < 14; i++) {
        b_currAdjoint[i + 14 * b_i] =
            currAdjoint[(idxRowsAdj[i] + 14 * b_i) - 1];
      }
    }
    mtimes(ADdata.constants.f7, b_currAdjoint, unusedExpr);
  }
  IsFiniteLeft = true;
  i = 0;
  exitg1 = false;
  while ((!exitg1) && (i < 56)) {
    if (muDoubleScalarIsInf(ADdata.constants.f6[i]) ||
        muDoubleScalarIsNaN(ADdata.constants.f6[i])) {
      IsFiniteLeft = false;
      exitg1 = true;
    } else {
      i++;
    }
  }
  if (IsFiniteLeft) {
    b_mtimes(ADdata.constants.f6, currAdjoint, rightJac);
  } else {
    real_T thisJac2[56];
    memset(&rightJac[0], 0, 56U * sizeof(real_T));
    for (i = 0; i < 14; i++) {
      idxRowsAdj[i] = (int8_T)(i + 1);
    }
    for (b_i = 0; b_i < 14; b_i++) {
      for (i = 0; i < 14; i++) {
        b_currAdjoint[i + 14 * b_i] =
            currAdjoint[(idxRowsAdj[i] + 14 * b_i) - 1];
      }
    }
    b_mtimes(ADdata.constants.f6, b_currAdjoint, thisJac2);
    for (b_i = 0; b_i < 14; b_i++) {
      i = b_i << 2;
      rightJac[i] = thisJac2[i];
      rightJac[i + 1] = thisJac2[i + 1];
      rightJac[i + 2] = thisJac2[i + 2];
      rightJac[i + 3] = thisJac2[i + 3];
    }
  }
  for (b_i = 0; b_i < 14; b_i++) {
    i = b_i << 2;
    arg41[18 * b_i + 14] = rightJac[i];
    arg41[18 * b_i + 15] = rightJac[i + 1];
    arg41[18 * b_i + 16] = rightJac[i + 2];
    arg41[18 * b_i + 17] = rightJac[i + 3];
  }
  IsFiniteLeft = true;
  i = 0;
  exitg1 = false;
  while ((!exitg1) && (i < 196)) {
    if (muDoubleScalarIsInf(ADdata.constants.f5[i]) ||
        muDoubleScalarIsNaN(ADdata.constants.f5[i])) {
      IsFiniteLeft = false;
      exitg1 = true;
    } else {
      i++;
    }
  }
  if (IsFiniteLeft) {
    c_mtimes(ADdata.constants.f5, currAdjoint, b_rightJac);
  } else {
    real_T b_thisJac2[196];
    memset(&b_rightJac[0], 0, 196U * sizeof(real_T));
    for (i = 0; i < 14; i++) {
      idxRowsAdj[i] = (int8_T)(i + 1);
    }
    for (b_i = 0; b_i < 14; b_i++) {
      for (i = 0; i < 14; i++) {
        b_currAdjoint[i + 14 * b_i] =
            currAdjoint[(idxRowsAdj[i] + 14 * b_i) - 1];
      }
    }
    c_mtimes(ADdata.constants.f5, b_currAdjoint, b_thisJac2);
    for (i = 0; i < 14; i++) {
      idxRowsAdj[i] = (int8_T)(i + 1);
    }
    for (b_i = 0; b_i < 14; b_i++) {
      for (i = 0; i < 14; i++) {
        b_rightJac[(idxRowsAdj[i] + 14 * b_i) - 1] = b_thisJac2[i + 14 * b_i];
      }
    }
  }
  for (b_i = 0; b_i < 14; b_i++) {
    memcpy(&arg41[b_i * 18], &b_rightJac[b_i * 14], 14U * sizeof(real_T));
  }
  for (b_i = 0; b_i < 18; b_i++) {
    for (i = 0; i < 14; i++) {
      J[i + 14 * b_i] = arg41[b_i + 18 * i];
    }
  }
  memcpy(&Jx[0], &J[0], 196U * sizeof(real_T));
  memcpy(&Ju[0], &J[196], 56U * sizeof(real_T));
}

/* End of code generation (nlmpc_config__stateFcnJacobian.c) */
